---
layout: post
title: "Outline of a proof-finding algorithm"
subtitle: "An introduction for people who would like to get up to speed quickly with the project"
date: 2022-05-17 10:00:00
background: '/img/maths_background.png'
author: "ATP Team"
mathjax: true
---

<p><strong>This page is under construction.</strong></p>

<p>The aim of this post is to describe a fully automatic proof-finding algorithm that is capable of finding proofs that are sufficiently routine. We hope that if you understand how it works, you will become familiar with many of the concepts and definitions that we will be working with when we design more advanced algorithms.
</p>

<h2 class="section-heading">A high-level overview</h2>

<p>A mathematics problem can be thought of as a statement that needs proving. Typically that statement involves some assumptions and a conclusion. For instance, the statement "A union of two closed sets is closed", when expressed more formally, gives us two sets $A$ and $B$ in a metric space, and we want to prove that $A\cup B$ is closed given the assumption that $A$ and $B$ are both closed.</p>

<p>However, our proof will typically involve more than mere logical operations: in order to prove that $A\cup B$ is closed, we will use not just the assumptions that we are explicitly given, but also a bank of background knowledge such as the definition of a closed set, the definition of an open set, and the fact that if $\epsilon_1$ and $\epsilon_2$ are positive real numbers then $\min\{\epsilon_1,\epsilon_2\}$ is another positive real number that is less than or equal to both $\epsilon_1$ and $\epsilon_2$.</p>

<p>We therefore think of the algorithm as follows. The input consists of an <em>initial problem state</em> $S_0$, which is a suitably formal statement of what is to be proved, and a <em>library</em>, which is a bank of facts that can be assumed. The algorithm then produces a sequence of problem states $S_0,S_1,\dots,S_k$, each of which is a statement to be proved. This sequence must obey the rule that $S_{i+1}$ implies $S_i$ for each $i$: that is, if we can successfully prove the statement $S_{i+1}$, then that means we have proved the statement $S_i$. If $S_k$ is the trivial statement TRUE, then the algorithm has succeeded, and given us a proof of $S_0$.</p> 
  
<p> In order to transform one problem statement into another, the algorithm has access to a collection of <em>move types</em>, which can be thought of as partial functions (or more generally, since a move type can sometimes be applied in more than one way, relations) defined on the set of all problem states. Thus, if we want to look at things in a very abstract way, we can think of the problem we wish to solve as that of finding a path in a directed graph. The vertices of the graph are all problem states, there is an edge from $S$ to $S'$ if and only if there is a move type $M$ such that $S\to_M S'$ (where this means that $S$ can be transformed to $S'$ using a move of move type $M$), and our aim is to find a directed path from an initial vertex $S_0$ to the vertex TRUE. However, while in full generality the question of how to find a shortest path in a graph is well understood, for this problem the graph has a lot of structure, coming from the interesting way that the vertices and edges are labelled. We thus face the problem of understanding how these labellings can enable us to find short paths much more quickly, and that is a much more challenging question.</p>
  
<h2>Problem states, tableaux, and move types</h2> 

</p>While we do not always represent problem states this way, deep down they are just formulae built up in a standard way from variables, functions, predicates, relations of various arities, connectives, quantifiers, and so on. Returning to the example given earlier, the initial problem state if we want to prove that a union of two closed sets is closed might be the following.

$$\forall (X,d):\text{metric space}\ \ \forall A:\text{subset of }X\ \ \forall B:\text{subset of }X$$

$$\ \ \ \text{is_closed}(A,X)\ \wedge\ \text{is_closed}(B,X)\implies\text{is_closed}(A\cup B,X)$$
</p>

<p>There are a few choices that need to be made, which we briefly comment on here. For example, the above statement contains type declarations such as that $(X,d)$ is a metric space. An alternative might be to quantify over all sets $X$ (which of course form a proper class rather than a set) and all functions $d:X\times X\to\mathbb R$ and then to adopt the statement $\text{metric\_space}(X,d)$ as an assumption. Or we might prefer to fix once and for all a metric space $X$ instead of universally quantifying over them, to reflect the way a human mathematician would state the theorem starting with the words "Let $(X,d)$ be a metric space." Also, $\text{is_closed}$ is treated here as a two-variable predicate (corresponding to the idea of one set being closed in another) rather than a one-variable predicate with $X$ being considered to be clear from the context. But these are more like implementation details than fundamental aspects of the algorithm.</p> 

<p>It is often convenient to represent a problem state by simply listing the type declarations, the assumptions, and the desired conclusion. For example, the above formula can be represented in the following way.
  
  $$\begin{array}{|c|}
  \hline
  (X,d): \text{metric space}\\
  A: \text{subset of }X\\
  B: \text{subset of }X\\
  \hline
  \\
  \hline
  \text{is_closed}(A,X)\\
  \text{is_closed}(B,X)\\
  \hline
  \\
  \hline
  \text{is_closed}(A\cup B,X)\\
  \hline
  \end{array}$$
</p>



